subroutine copy_y(ye,ieo)
!***********************************************************************
!$Id: copy_y.h90,v 1.2 2009/12/03 01:52:31 ishikawa Exp $
! Boundary copy for a fermion vector
!
!      ye : even/odd site quark field (ieo=0/1)
!     ieo : operation index
!             ieo=0 for even site
!             ieo=1 for odd  site
!
!***********************************************************************
  implicit none
  complex(8), intent(inout) :: ye(COL,SPIN,0:NTH,0:NZ1,0:NY1,0:NX1)
  integer , intent(in) :: ieo
  integer :: ix,iy,iz,itb,ieoxyz,itb0,itb1,ic,is
  integer :: ibuff,jbuff
  real(8) :: etime0,etime1,btime0,btime1

  call xclock(etime0,8)
#ifndef _singlePU
  call comlib_barrier
#endif


!***** T - boundaray
!$OMP PARALLEL DO PRIVATE(ix,iy,iz,ieoxyz,itb0,itb1,ic,is)
  do ix=1,NX
  do iy=1,NY
  do iz=1,NZ
    ieoxyz = mod(ipeo+ix+iy+iz+ieo,2)
    itb0 =    ieoxyz *NTH
    itb1 = (1-ieoxyz)*NTH
    do is=1,SPIN
    do ic=1,COL
      ye(ic,is,itb0,iz,iy,ix)=ye(ic,is,itb1,iz,iy,ix)
    enddo
    enddo
  enddo
  enddo
  enddo

!***********************************************************************
!********************** copy without cornar
!***** Z - boundaray
#if _NDIMZ == 1
!$OMP PARALLEL DO PRIVATE(ix,iy,itb,ic,is)
    do ix=1,NX
    do iy=1,NY
      do itb=0,NTH
        do is=1,SPIN
        do ic=1,COL
          ye(ic,is,itb,  0,iy,ix)=ye(ic,is,itb,NZ,iy,ix)
          ye(ic,is,itb,NZ1,iy,ix)=ye(ic,is,itb, 1,iy,ix)
        enddo
        enddo
      enddo
    enddo
    enddo
#else
!    ibuff=0
!$OMP PARALLEL DO PRIVATE(ix,iy,itb,ic,is,ibuff)
    do ix=1,NX
    do iy=1,NY
      do itb=0,NTH
        do is=1,SPIN
        do ic=1,COL
!          ibuff=ibuff+1
          ibuff=ic+(is-1)*COL+itb*CLSP+(iy-1)*CLSP*(NTH+1)+(ix-1)*CLSP*(NTH+1)*NY
          fbuffup(ibuff,1,3)=ye(ic,is,itb,NZ,iy,ix)
          fbuffdn(ibuff,1,3)=ye(ic,is,itb, 1,iy,ix)
        enddo
        enddo
      enddo
    enddo
    enddo

    call xclock(btime0,8)
    call comlib_sendrecv( idfsendup(3) )
    call comlib_sendrecv( idfsenddn(3) )
    call xclock(btime1,8)
    copy_y_time(3)=copy_y_time(3)+(btime1-btime0)
    copy_y_size(3)=copy_y_size(3)+FBUFF_SIZE(3)*2

!    ibuff=0
!$OMP PARALLEL DO PRIVATE(ix,iy,itb,ic,is,ibuff)
    do ix=1,NX
    do iy=1,NY
      do itb=0,NTH
        do is=1,SPIN
        do ic=1,COL
!          ibuff=ibuff+1
          ibuff=ic+(is-1)*COL+itb*CLSP+(iy-1)*CLSP*(NTH+1)+(ix-1)*CLSP*(NTH+1)*NY
          ye(ic,is,itb,  0,iy,ix)=fbuffup(ibuff,2,3)
          ye(ic,is,itb,NZ1,iy,ix)=fbuffdn(ibuff,2,3)
        enddo
        enddo
      enddo
    enddo
    enddo
#endif

!***** Y - boundaray
#if _NDIMY == 1
!$OMP PARALLEL DO PRIVATE(ix,iz,itb,ic,is)
    do ix=1,NX
    do iz=1,NZ
      do itb=0,NTH
        do is=1,SPIN
        do ic=1,COL
          ye(ic,is,itb,iz,  0,ix)=ye(ic,is,itb,iz,NY,ix)
          ye(ic,is,itb,iz,NY1,ix)=ye(ic,is,itb,iz, 1,ix)
        enddo
        enddo
      enddo
    enddo
    enddo
#else
!$OMP PARALLEL DO PRIVATE(ix,iz,itb,ic,is,ibuff)
    do ix=1,NX
    do iz=1,NZ
      do itb=0,NTH
        do is=1,SPIN
        do ic=1,COL
          ibuff=ic+(is-1)*COL+itb*CLSP+(iz-1)*CLSP*(NTH+1)+(ix-1)*CLSP*(NTH+1)*NZ
          fbuffup(ibuff,1,2)=ye(ic,is,itb,iz,NY,ix)
          fbuffdn(ibuff,1,2)=ye(ic,is,itb,iz, 1,ix)
        enddo
        enddo
      enddo
    enddo
    enddo

    call xclock(btime0,8)
    call comlib_sendrecv( idfsendup(2) )
    call comlib_sendrecv( idfsenddn(2) )
    call xclock(btime1,8)
    copy_y_time(2)=copy_y_time(2)+(btime1-btime0)
    copy_y_size(2)=copy_y_size(2)+FBUFF_SIZE(2)*2

!$OMP PARALLEL DO PRIVATE(ix,iz,itb,ic,is,ibuff)
    do ix=1,NX
    do iz=1,NZ
      do itb=0,NTH
        do is=1,SPIN
        do ic=1,COL
          ibuff=ic+(is-1)*COL+itb*CLSP+(iz-1)*CLSP*(NTH+1)+(ix-1)*CLSP*(NTH+1)*NZ
          ye(ic,is,itb,iz,  0,ix)=fbuffup(ibuff,2,2)
          ye(ic,is,itb,iz,NY1,ix)=fbuffdn(ibuff,2,2)
        enddo
        enddo
      enddo
    enddo
    enddo
#endif

!***** X - boundaray
#if _NDIMX == 1
!$OMP PARALLEL DO PRIVATE(iy,iz,itb,ic,is)
    do iy=1,NY
    do iz=1,NZ
      do itb=0,NTH
        do is=1,SPIN
        do ic=1,COL
          ye(ic,is,itb,iz,iy,  0)=ye(ic,is,itb,iz,iy,NX)
          ye(ic,is,itb,iz,iy,NX1)=ye(ic,is,itb,iz,iy, 1)
        enddo
        enddo
      enddo
    enddo
    enddo
#else
!$OMP PARALLEL DO PRIVATE(iy,iz,itb,ic,is,ibuff)
    do iy=1,NY
    do iz=1,NZ
      do itb=0,NTH
        do is=1,SPIN
        do ic=1,COL
          ibuff=ic+(is-1)*COL+itb*CLSP+(iz-1)*CLSP*(NTH+1)+(iy-1)*CLSP*(NTH+1)*NZ
          fbuffup(ibuff,1,1)=ye(ic,is,itb,iz,iy,NX)
          fbuffdn(ibuff,1,1)=ye(ic,is,itb,iz,iy, 1)
        enddo
        enddo
      enddo
    enddo
    enddo

    call xclock(btime0,8)
    call comlib_sendrecv( idfsendup(1) )
    call comlib_sendrecv( idfsenddn(1) )
    call xclock(btime1,8)
    copy_y_time(1)=copy_y_time(1)+(btime1-btime0)
    copy_y_size(1)=copy_y_size(1)+FBUFF_SIZE(1)*2

!$OMP PARALLEL DO PRIVATE(iy,iz,itb,ic,is,ibuff)
    do iy=1,NY
    do iz=1,NZ
      do itb=0,NTH
        do is=1,SPIN
        do ic=1,COL
          ibuff=ic+(is-1)*COL+itb*CLSP+(iz-1)*CLSP*(NTH+1)+(iy-1)*CLSP*(NTH+1)*NZ
          ye(ic,is,itb,iz,iy,  0)=fbuffup(ibuff,2,1)
          ye(ic,is,itb,iz,iy,NX1)=fbuffdn(ibuff,2,1)
        enddo
        enddo
      enddo
    enddo
    enddo
#endif

  call xclock(etime1,8)
  copyftime=copyftime+(etime1-etime0)

  return
end subroutine
